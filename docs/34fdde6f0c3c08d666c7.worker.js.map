{"version":3,"sources":["webpack:///webpack/bootstrap 34fdde6f0c3c08d666c7","webpack:///./~/json-delta/index.js","webpack:///./src/services/ledger-worker.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;AChEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnRA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA,iCAAiC,mCAAmC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oCAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"34fdde6f0c3c08d666c7.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 34fdde6f0c3c08d666c7","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isInsert(d) {\n    return isArr(d[0]);\n}\nexports.isInsert = isInsert;\nfunction isObj(o) {\n    return o instanceof Object && !(o instanceof Array);\n}\nexports.isObj = isObj;\nfunction isArr(o) {\n    return o instanceof Array;\n}\nexports.isArr = isArr;\nfunction shallowCopy(o) {\n    if (isObj(o))\n        return Object.assign({}, o);\n    if (isArr(o))\n        return o.slice();\n    return o;\n}\nexports.shallowCopy = shallowCopy;\nfunction getContainer(orig, result, path) {\n    let len = path.length;\n    if (!len)\n        return undefined;\n    let origContainer = orig;\n    let container = result;\n    if (container === origContainer)\n        container = shallowCopy(origContainer);\n    for (let i = 0; i < len - 1; ++i) {\n        let seg = path[i];\n        if (typeof seg === \"number\" && isArr(origContainer) && isArr(container)) {\n            origContainer = origContainer[seg];\n            if (container[seg] === origContainer) {\n                container = container[seg] = shallowCopy(origContainer);\n            }\n            else {\n                container = container[seg];\n            }\n        }\n        if (typeof seg === \"string\" && isObj(origContainer) && isObj(container)) {\n            origContainer = origContainer[seg];\n            if (container[seg] === origContainer) {\n                container = container[seg] = shallowCopy(origContainer);\n            }\n            else {\n                container = container[seg];\n            }\n        }\n    }\n    return container;\n}\nexports.getContainer = getContainer;\nfunction getVal(container, path) {\n    let len = path.length;\n    for (let i = 0; i < len; ++i) {\n        let seg = path[i];\n        if (typeof seg === \"number\" && isArr(container)) {\n            container = container[seg];\n        }\n        if (typeof seg === \"string\" && isObj(container)) {\n            container = container[seg];\n        }\n    }\n    return container;\n}\nexports.getVal = getVal;\nfunction applyDiff(o, d) {\n    if (!d)\n        return o;\n    let result = shallowCopy(o);\n    d.forEach(p => {\n        if (isInsert(p))\n            result = applyInsert(o, result, p);\n        else\n            result = applyDelete(o, result, p);\n    });\n    return result;\n}\nexports.applyDiff = applyDiff;\nfunction applyInsert(orig, result, insert) {\n    let [path, val] = insert;\n    let container = getContainer(orig, result, path);\n    if (!container)\n        return val;\n    let key = path[path.length - 1];\n    if (typeof key === \"number\" && isArr(container)) {\n        container.splice(key, 0, val);\n    }\n    if (typeof key === \"string\" && isObj(container)) {\n        container[key] = val;\n    }\n    return result;\n}\nexports.applyInsert = applyInsert;\nfunction applyDelete(orig, result, path) {\n    let container = getContainer(orig, result, path);\n    if (!container)\n        return null;\n    let key = path[path.length - 1];\n    if (typeof key === \"number\" && isArr(container)) {\n        container.splice(key, 1);\n        return result;\n    }\n    if (typeof key === \"string\" && isObj(container)) {\n        delete container[key];\n        return result;\n    }\n    return null;\n}\nexports.applyDelete = applyDelete;\nfunction diff(a, b, tolerance = Infinity) {\n    let result = [];\n    if (gatherDiff(a, b, tolerance, [], result) || result.length > tolerance)\n        return [[[], b]];\n    if (result.length === 0)\n        return null;\n    return result;\n}\nexports.diff = diff;\nfunction gatherDiff(a, b, tolerance = 3, path, result) {\n    if (a === undefined)\n        a = null;\n    if (b === undefined)\n        b = null;\n    if (typeof a === \"number\" && isNaN(a))\n        a = null;\n    if (typeof b === \"number\" && isNaN(b))\n        b = null;\n    if (a === b)\n        return false;\n    if (typeof a !== typeof b) {\n        result.push([path, b]);\n        return false;\n    }\n    if (a instanceof Array) {\n        if (!(b instanceof Array)) {\n            result.push([path, b]);\n            return false;\n        }\n        let offset = 0;\n        const thunks = [];\n        if (!arrDiff(a, b, tolerance - result.length, () => thunks.push(() => ++offset), (aIdx, bIdx) => thunks.push(() => result.push(path.concat([offset]))), (aIdx, bIdx) => thunks.push(() => {\n            result.push([path.concat([offset++]), b[bIdx]]);\n        })))\n            return true;\n        for (let i = thunks.length - 1; i >= 0; --i) {\n            thunks[i]();\n        }\n        return false;\n    }\n    if (b instanceof Array) {\n        result.push([path, b]);\n        return false;\n    }\n    if (a instanceof Object) {\n        if (!(b instanceof Object)) {\n            result.push([path, b]);\n            return false;\n        }\n        for (var k in a) {\n            if (!(k in b)) {\n                result.push(path.concat([k]));\n                if (result.length > tolerance) {\n                    return true;\n                }\n                continue;\n            }\n            if (gatherDiff(a[k], b[k], tolerance, path.concat([k]), result)) {\n                return true;\n            }\n            if (result.length > tolerance) {\n                return true;\n            }\n        }\n        for (var k in b) {\n            if (!(k in a)) {\n                result.push([path.concat([k]), b[k]]);\n                if (result.length > tolerance) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    result.push([path, b]);\n    return false;\n}\nfunction deepEqual(a, b) {\n    return a === b || diff(a, b, 0) == null;\n}\nexports.deepEqual = deepEqual;\n/**\n * Finds the longest common subsequence between a and b,\n * optionally shortcutting any search whose removed elements\n * would exceed the provided tolerance value.\n * If there is no match within the provided tolerance, this function\n * returns null.\n */\nfunction lcs(a, b, tolerance = a.length + b.length) {\n    let result = [];\n    return arrDiff(a, b, tolerance, aIdx => result.push(a[aIdx]))\n        ? result.reverse()\n        : null;\n}\nexports.lcs = lcs;\nfunction arrDiff(a, b, tolerance = a.length + b.length, onEq, onPickA = () => null, onPickB = () => null) {\n    tolerance = Math.min(tolerance, a.length + b.length);\n    let aLen = a.length;\n    let bLen = b.length;\n    let aOfDiagonal = new Uint32Array(tolerance * 2 + 2);\n    let aOfDiagonalForEditSize = new Array(tolerance + 1);\n    let shortestEdit = (function () {\n        for (var d = 0; d <= tolerance; ++d) {\n            for (var k = -d; k <= d; k += 2) {\n                let aIdx;\n                let takeB = aOfDiagonal[k + 1 + tolerance];\n                let takeA = aOfDiagonal[k - 1 + tolerance];\n                if (k === -d || (k !== d && takeA < takeB)) {\n                    aIdx = takeB;\n                }\n                else {\n                    aIdx = takeA + 1;\n                }\n                let bIdx = aIdx - k;\n                while (aIdx < aLen &&\n                    bIdx < bLen &&\n                    deepEqual(a[aIdx], b[bIdx])) {\n                    aIdx++;\n                    bIdx++;\n                }\n                aOfDiagonal[k + tolerance] = aIdx;\n                if (aIdx >= aLen && bIdx >= bLen) {\n                    aOfDiagonalForEditSize[d] = aOfDiagonal.slice();\n                    return [d, k];\n                }\n            }\n            aOfDiagonalForEditSize[d] = aOfDiagonal.slice();\n        }\n        return null;\n    })();\n    if (shortestEdit) {\n        let [d, k] = shortestEdit;\n        let aIdx = aOfDiagonalForEditSize[d][k + tolerance];\n        let bIdx = aIdx - k;\n        while (d > 0) {\n            let k = aIdx - bIdx;\n            let v = aOfDiagonalForEditSize[d - 1];\n            let prevK;\n            if (k === -d || (k !== d && v[k - 1 + tolerance] < v[k + 1 + tolerance])) {\n                prevK = k + 1;\n            }\n            else {\n                prevK = k - 1;\n            }\n            let prevAIdx = v[prevK + tolerance];\n            let prevBIdx = prevAIdx - prevK;\n            while (aIdx > prevAIdx && bIdx > prevBIdx) {\n                onEq(--aIdx, --bIdx);\n            }\n            if (aIdx > prevAIdx) {\n                onPickA(--aIdx, bIdx);\n            }\n            else if (bIdx > prevBIdx) {\n                onPickB(aIdx, --bIdx);\n            }\n            --d;\n        }\n        while (aIdx > 0 && bIdx > 0) {\n            onEq(--aIdx, --bIdx);\n        }\n        return true;\n    }\n    return false;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-delta/index.js\n// module id = 0\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jd = require(\"json-delta\");\nif (typeof importScripts === \"function\") {\n    run();\n}\nfunction run() {\n    let openReq = indexedDB.open(\"ledger-storage-3\", 1);\n    let db;\n    let queuedRequests = [];\n    let keyStates = {};\n    let queuedWrite = {};\n    let writing = {};\n    let requestedSaveValues = {};\n    const STORE_NAME = \"ledger\";\n    const INDEX_NAME = \"key\";\n    openReq.onupgradeneeded = e => {\n        let db = e.target.result;\n        let store = db.createObjectStore(STORE_NAME, {\n            keyPath: \"seq\",\n            autoIncrement: true,\n        });\n        store.createIndex(INDEX_NAME, \"objKey\");\n    };\n    openReq.onsuccess = e => {\n        db = openReq.result;\n        var requests = queuedRequests;\n        queuedRequests = [];\n        for (var i = 0; i < requests.length; ++i) {\n            runRequest(db && db, requests[i]);\n        }\n    };\n    function reply(message) {\n        self.postMessage(message);\n    }\n    function doWrite(db, key, value, state) {\n        writing[key] = true;\n        var startWrite = Date.now();\n        var tx = db.transaction(STORE_NAME, \"readwrite\");\n        var store = tx.objectStore(STORE_NAME);\n        var index = store.index(INDEX_NAME);\n        var req = index.openKeyCursor(IDBKeyRange.only(key), \"prev\");\n        req.onsuccess = e => {\n            let cursor = e.target.result;\n            let req;\n            if (cursor && cursor.primaryKey === state.curSeq) {\n                var startDiff = Date.now();\n                var diff = jd.diff(state.curVal, value, 30);\n                // console.log(\"putting diff\", key, diff, Date.now() - startDiff);\n                req = store.put({ objKey: key, diff });\n            }\n            else {\n                // console.log(\"putting reet diff\", cursor.key, cursor.primaryKey, state.curSeq, key, value);\n                req = store.put({ objKey: key, diff: [[[], value]] });\n            }\n            req.onsuccess = e => {\n                state.curSeq = req.result;\n                state.curVal = value;\n                // console.log(\"newState\", state);\n            };\n            req.onerror = e => {\n                console.error(e);\n            };\n        };\n        tx.oncomplete = () => {\n            writing[key] = false;\n            // console.log(\"completed write txn\", Date.now() - startWrite);\n            let queuedValue = queuedWrite[key];\n            if (key in queuedWrite) {\n                delete queuedWrite[key];\n                doWrite(db, key, queuedValue, state);\n            }\n        };\n    }\n    function runRequest(db, request) {\n        switch (request.type) {\n            case \"clear\":\n                var tx = db.transaction(STORE_NAME, \"readwrite\");\n                var objStoreReq = tx.objectStore(STORE_NAME).clear();\n                objStoreReq.onerror = e => {\n                    console.error(e);\n                };\n                tx.oncomplete = () => {\n                    keyStates = {};\n                };\n                break;\n            case \"save\":\n                var { key, diff } = request;\n                var state = (keyStates[key] = keyStates[key] || {\n                    curSeq: null,\n                    curVal: null,\n                });\n                var value = requestedSaveValues[key] = jd.applyDiff(requestedSaveValues[key], diff);\n                if (writing[key]) {\n                    queuedWrite[key] = value;\n                    break;\n                }\n                doWrite(db, key, value, state);\n                break;\n            case \"load\":\n                var { key, readSeq } = request;\n                var tx = db.transaction(STORE_NAME, \"readwrite\");\n                var store = tx.objectStore(STORE_NAME);\n                var index = store.index(INDEX_NAME);\n                var req = index.openCursor(IDBKeyRange.only(key));\n                var result = null;\n                var state = (keyStates[key] = {\n                    curSeq: -1,\n                    curVal: null,\n                });\n                var lastCursor = Date.now();\n                req.onsuccess = e => {\n                    let cursor = e.target.result;\n                    if (cursor) {\n                        var start = Date.now();\n                        result = jd.applyDiff(result, cursor.value.diff);\n                        // console.log(\"accumulating diff\", cursor.value, result, Date.now() - start, Date.now() - lastCursor);\n                        lastCursor = Date.now();\n                        const req = cursor.delete();\n                        req.onsuccess = () => {\n                            cursor.continue();\n                        };\n                    }\n                    else {\n                        console.log(\"putting finalized diff\", result);\n                        req = store.put({ objKey: key, diff: [[[], result]] });\n                        req.onsuccess = e => {\n                            state.curSeq = req.result;\n                            state.curVal = result;\n                            console.log(\"consolidated\", result, req.result);\n                        };\n                        req.onerror = e => {\n                            console.error(e);\n                        };\n                        reply({ key, readSeq, value: result });\n                    }\n                };\n                req.onerror = e => {\n                    console.error(e);\n                    reply({ key, readSeq, value: null });\n                };\n                break;\n        }\n    }\n    self.onmessage = function (event) {\n        let request = event.data;\n        if (!db)\n            queuedRequests.push(request);\n        else\n            runRequest(db, request);\n    };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/services/ledger-worker.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}